//Solveur de Labyrinth
//    /!\ LE CENTRE DE PIVOTEMENT N'EST PAS AU CENTRE DU ROBOT
/* SCHEMA
__________________________________ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ______
   |                       |                                      |
   |                       |                                      |
   |                       |                                      |
   |          _|_  _  _  _ | _ _ _ _ _ _ _ _ _ ____Pos avt rotat° |   19,5cm
   |           |           |                     |                |
   |          _|_    _  _ _|_  ___  pos apres rotat°              |
   |           |           |    |                |                |
   |                       |    | 8,5 cm         |                |
___|___________ ___________|____|___          ___|___          ___|___
La position est la position du centre géométrique du robot
c.a.d le centre d'un rectangle 19,5*13 cm²
*/
/*******************************************************************/

//Disposition des moteurs :
// A :  gauche
// B :  droite

// angle négatif : sens trigo
// angle positif : sens anti trigo

// sens de rotation:
//enum sens{droite, gauche};
/*
char speed_movement_rot = 70; //à regler
char speed_movement_back = 100;  //à regler
char speed_movement = 100;  //à regler
char duree_fw = 15000;  // peut être pas nécessaire (le robot va jusqu'a la ligne)
char duree_rot = 1030;
char light_white = 45;  // à regler
int ROUGE= 60  ;
int BLANC=63   ;       //     /!\ ces valeurs dépendent grandement de la luminosité
int NOIR = 42   ;      //     noir et blanc assez simple à differencier
int BLEU =47    ;      // reste une troisieme couleur a définir pour la sortie
int JAUNE=52    ;      // rouge et jaune eliminé car pr le capteur jaune~rouge~blanc

//taille du robot : 19,5 cm * 13 cm   (longeur * largeur)
//centre de pivotement : 8,5cm(distance du)
*/

#include "primitives.h"

/* Fonctions */
//fait avancer le robot pdt un certain temps
task avancer(){
   OnRevReg(OUT_AB, speed_movement, OUT_REGMODE_SYNC);
}

//fait reculer le robot pdt un certain temps
void reculer(int duree){
     OnFwdReg(OUT_AB, speed_movement,OUT_REGMODE_SYNC);
     Wait(duree);
     Off(OUT_AB);
}

// fait tourner le robot de 90° vers la gauche ou la droite
void turn(sens s, int duree)
{
  if(s==gauche)
  {
    OnRev(OUT_A, speed_movement_rot);
    OnFwd(OUT_B, speed_movement_rot);
    Wait(duree);
    Off(OUT_AB);
  }
  else if(s==droite)
  {
     OnRev(OUT_B, speed_movement_rot);
     OnFwd(OUT_A, speed_movement_rot);
     Wait(duree);
     Off(OUT_AB);
  }
}


void test_lum()
{
     int lum;   //couleur
     string strlum; // string de la couleur
     string couleur;
     string message1,message2 ;
      SetSensorLight(IN_3);
          do
          {
               lum=Sensor(IN_3);
              if(lum>=BLANC) couleur="blanc";
               else if(lum>=ROUGE && lum<BLANC) couleur="rouge";
              else if(lum>=JAUNE && lum <ROUGE) couleur="jaune";
              else if(lum>=BLEU && lum<JAUNE) couleur="bleu";
              else if(lum<BLEU) couleur="noir";
              else couleur="unknow";
              strlum=NumToStr(lum)  ;
              message1=StrCat("valeur :", strlum);
              message2=StrCat("couleur :", couleur);
              TextOut(5, LCD_LINE3, message1);
              TextOut(5, LCD_LINE4, message2);
              Wait(100); // 10 mesures par seconde
           } while(true);
}

task main()
{
    // test_lum();
      // avancer(SEC_2);
    // OnRevReg(OUT_AB,speed_movement,OUT_REGMODE_SYNC);
     /*avancer(1500);*/
    // while(detection_ligne_blanche()==0)
     //{
       // avancer(SEC_2);
       // Wait(SEC_2);
    // }
    // turn(gauche,1030);
    // Wait(SEC_2);
    // turn(droite,1030);
    // detection_ligne_blanche();
}
